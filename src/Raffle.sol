//* These are the layout from the solidity docs for readability.

// Layout of Contract:
// version
// imports
// errors
// interfaces, libraries, contracts
// Type declarations
// State variables
// Events
// Modifiers
// Functions

// Layout of Functions:
// constructor
// receive function (if exists)
// fallback function (if exists)
// external
// public
// internal
// private
// view & pure functions

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
// Imports
import {VRFConsumerBaseV2Plus} from "lib/chainlink-brownie-contracts/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import {VRFV2PlusClient} from "lib/chainlink-brownie-contracts/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";



/* 
    @title A Raffle Contract
    @author Talha Riaz
    @notice This contract is for creating a decentralized raffle
    @dev This implements chainlink VRFv2.5 keepers to ensure the contract can be executed
*/
contract Raffle is VRFConsumerBaseV2Plus {


    // errors
    error Raffle__NotEnoughEthSent();
    error Raffle__TransferFailed();

    //CONSTANTS
    uint16 private constant REQUEST_CONFIRMATIONS = 3;
    uint32 private constant NUM_WORDS = 1;
    //State Variables
    uint256 private immutable i_entranceFee;
    address payable[] private s_players; //* storage variable and it keep change and payable because any address can send eth
    uint256 private immutable i_interval;
    uint256 private s_lastTimeStamp;
    bytes32 private immutable i_keyhash;
    uint256 private immutable i_subscriptionId;
    uint32 private immutable i_callbackGasLimit;
    address payable private s_recentWinner;
    //Events ---> //* For migration from 1 contract to another, just listen and even helpful on the frontend
    event RaffleEnter(address indexed player); //* indexed is used to make the query better on the player address. EVM log --> Event --> index make topic in that event
        
    constructor(uint256 entranceFee, uint256 interval, address vrfCoordinatorV2, uint256 subscriptionId, bytes32 keyhash, uint32 callbackGasLimit)
    VRFConsumerBaseV2Plus(vrfCoordinatorV2) {
        i_entranceFee = entranceFee;
        i_interval = interval;
        s_lastTimeStamp = block.timestamp; //* The time when the contract is deployed
        i_keyhash = keyhash;
        i_subscriptionId = subscriptionId;
        i_callbackGasLimit = callbackGasLimit;
    }

    function enterRaffle() external payable {
        if(msg.value < i_entranceFee) { //* More gas efficent than require but now we can pass custom error in require as well in 0.18.26 version of solidity
            revert Raffle__NotEnoughEthSent();
        }
        s_players.push(payable(msg.sender)); //* msg.sender is the address of the sender and make it payable because we want to store the address of the sender in the array as payable
        emit RaffleEnter(msg.sender);
    }

    function pickWinner() external {
        if((block.timestamp - s_lastTimeStamp) < i_interval) { //* Here bloc.timestamp is the current time and s_lastTimeStamp is the time when the contract is deployed and if < then mean we have to wait for the interval to pass
            revert ();
        }
        VRFV2PlusClient.RandomWordsRequest memory request = VRFV2PlusClient.RandomWordsRequest({
                keyHash: i_keyhash, //* s_keyHash is the gas lane that you want to use. The gas price.
                subId: i_subscriptionId, //* s_subscriptionId is the subscription id of the chainlink node
                requestConfirmations: REQUEST_CONFIRMATIONS, //* requestConfirmations is the number of confirmations you want to wait for the random number, As more, more secure
                callbackGasLimit: i_callbackGasLimit, //* callbackGasLimit is the gas limit for the callback function, s_keyHash is the gas lane that you want to use and this limit of gas
                numWords: NUM_WORDS, //* numWords is the number of random words you want to request
                extraArgs: VRFV2PlusClient._argsToBytes(
                    // Set nativePayment to true to pay for VRF requests with Sepolia ETH instead of LINK
                    VRFV2PlusClient.ExtraArgsV1({nativePayment: false})
                )
            });
            
            uint256 requestId = s_vrfCoordinator.requestRandomWords(request);
    }

    //* This is the abstract function we have to implement from the VRFConsumerBaseV2Plus contract, This is callback that will be called when the random number is generated by chainlink node and we will get the random number in randomWords array and can do what we want.
    function fulfillRandomWords(uint256 requestId, uint256[] calldata randomWords) internal override { //*requestId is the id of the req that we did above
        //* What is modulo? Actually it is the remainder of the division of two numbers. so if you divide 34892375823758723857 % 10 then remainder must be between 0 to 9. That's great actually. 

    //* WHat we will do is to pick the random number and length of the s_players array and get the modulo and decalre the winner without outbound
    uint256 indexOfWinner = randomWords[0] % s_players.length;
    address payable recentWinner = s_players[indexOfWinner];
    s_recentWinner = recentWinner;
    (bool success, ) = recentWinner.call{value: address(this).balance}(""); //* This will send all the contract balance of contract (got from all players) to the winner
    if(!success) {
        revert Raffle__TransferFailed();
    }

    }





    /* GETTER FUNCTIONS */
    function getEntranceFee() public view returns (uint256) {
        return i_entranceFee;
    }

}


//* Chainlink is the oracle network and we used the VRF feature of chainlink to get the random number /* Steps: 1) Make Subscription 2) Fund Subscription  3) Deploy Consumer Contract 4) Create Request 5) Chainlink Node will give the random number */
//* We have 2 methods for using VRF: 1) Subscription (Subscription contract-> Fund -> Req -> Get the Random num) 2) Direct Funding (Not Recommended Because we directly fund the contract (here Raffle) and each time we have to fund)
